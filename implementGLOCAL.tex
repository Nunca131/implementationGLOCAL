\documentclass[a4paper,10pt]{article}

\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{natbib}
%%%% nasty hack to get rid of conflict of an annoying conflict
\makeatletter
\let\bibhang\@undefined
\makeatother
%%%% 
\usepackage{apalike}
% Please add other packages that you may need BEFORE the SCITEPRESS.sty package.
\usepackage{xcolor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{SCITEPRESS}

\subfigtopskip=0pt
\subfigcapskip=0pt
\subfigbottomskip=0pt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\TODO}[1]{\begingroup\color{red}#1\endgroup}
\newcommand{\PFS}[1]{\begingroup\color{green}#1\endgroup}
\newcommand{\NR}[1]{\begingroup\color{orange}#1\endgroup}
\newcommand{\FK}[1]{\begingroup\color{blue}#1\endgroup}

\newcommand{\DINGENS}[1]{\texttt{DINGENS}}
\newcommand{\pprec}{\mathrel{\prec\!\!\!\prec}}
\newcommand{\SAFTWARE}{\TODO{\texttt{SAFTWARE}}}

\begin{document}

\title{A General Framework for Exact Partially Local Alignments}

\author{\authorname{Falco Kirchner\sup{1},
    Nancy Retzlaff\sup{2,1}, and
    Peter F.\ Stadler\sup{1,2,3,4,5}}
  \affiliation{\sup{1}Bioinformatics Group, Department of Computer Science,
      and Interdisciplinary Center for Bioinformatics,
      H{\"a}rtelstra{\ss}e 16-18, D-04107 Leipzig, Germany}
  \affiliation{\sup{2}Max Planck Institute for Mathematics in the Sciences,
    Inselstra{\ss}e 22, D-04103 Leipzig, Germany}
  \affiliation{\sup{3}Institute for Theoretical Chemistry, University of Vienna,
    W{\"a}hringerstra{\ss}e 17, A-1090 Wien, Austria}
  \affiliation{\sup{4}Santa Fe Institute, 1399 Hyde Park Road,
    Santa Fe NM 87501, USA}
  \email{FALCO@nirwana.net, \{nancy,studla\}@bioinf.uni-leipzig.de}
}

\keywords{Multiple sequence alignments, dynamics programming} 

\abstract{Multiple sequence alignments are a crucial intermediate step in a
  plethora of data analysis workflows in computational biology. While
  multiple sequence alignments are usually constructed with the help of
  heuristic approximations, while pairwise alignments are typically
  computed by exact dynamic programming algorithms. In the pairwise case,
  local, global, and semi-global alignments are distinguished, with key
  applications in pattern discovery, gene comparison, and homolgy search,
  respectively. With increasing computing power, exact alignments of
  triples and even quadruples of sequences have become feasible and recent
  applications e.g.\ in the context breakpoint discovery have shown that
  mixed local/global multiple alignments can be of practical interest.
  \DINGENS{} is the first implementation of partially local multiple
  alignments of a few sequences and provides convenient access to this
  family of specialized alignment algorithms.}

\onecolumn \maketitle \normalsize \vfill

\section{\uppercase{Introduction}}

\noindent
Global multiple alignments are typically constructed as intermediate data
structure to support a comparative or evolutionary analysis homologous
sequences. Alignment probablems are naturally treated as optimization
problems: a scoring function evaluates the similarities in an alignment
column and/or the pattern of gaps. Multiple alignments are almost
exclusively treated globally, that is, all parts of the input sequence is
scored. The notion of ``local multiple alignments'' refer to short, usually
gapless patterns \citep{Lukashin:99,Blanchette:02} arising in phylogenetic
footprinting and related pattern discovery problems  \citep{Tabei:09}.

Local variants of sequence alignment, on the hand, play an important role
in pairwise alignments. Local alignments, i.e., maximally similar
substrings within pairs of longer sequences, are a natural way to identify
conserved domains.  The semi-global variant of pairwise alignment, in which
one sequence, usually called ``query'', is expected to appear as
approximate substring of a larger ``subject'', again is a natural
formalization of homology search, implemented e.g.\ in \texttt{gotohscan}
\citep{Hertel:09a}.  Overlap alignments
\citep{Jones:04} allowing free end gaps on all sequences have applications
e.g.\ in sequence assembly \citep{Rausch:09}. Until recently, the
generalization of these variants to more than two sequences has received
very little attention.

Pairwise alignment problems can be solved exactly for a wide range of cost
models by means of dynamic programming. In fact, the algorithms of
\citet{Needleman:70} for global alignments, \citet{Smith:81} for local
alignments, and the extension to affine gap costs by \citet{Gotoh:82} are
among the early, paradigmatic example of dynamic programming. The basic
recursive structure is readily extended to more than two input sequences
\citep{Carillo:88,Lipman:89}; the time and space complexity, however, grows
exponentially with the number of sequences. Exact dynamic programming
solutions thus have been used in practice only for 3-way
\citep{Gotoh:86,Dewey:01,Konagurthu:04,Kruspe:07a} or 4-way
\citep{Steiner:11a} alignments. Since multipe sequence alignment problems
(for arbitrary numbers of input sequences $X$ are typically NP-hard
\citep{Kececioglu:93,Wang:94,Bonizzoni:01,Just:01,Manthey:03,Elias:06},
they are solved by heuristic approximation algorithms, see
\citet{Baichoo:17} for a recent review.

As the exact 3-way and 4-way alignments have increased in usage, variants
of the problem that combine local and global alignments have been proposed
for specialized application scenarios. \citet{AlArab:17a} considered the
fate of sequences in the wake of mitochondrial genome rearrangments by
simultaneously comparing the rearranged region to both of its
ancestors. This approach made it possible to distinguish tandem duplication
random loss (TDRL) from reversal or transposition events. This specialized
3-way alignment problem suggested the need to develop a general theoretical
framework for alignments that consider part of their input local and part
global. As shown by \citet{Retzlaff:18a} it is possible -- and convenient
-- to allow the user determine separately for each input sequence and each
of its ends, whether it is to be treated as global, i.e., deletions of a
prefix or a suffix are penalized, or as local, allowing the omission of
prefixes or suffixes at not cost. We will briefly outline the theoretical
results in the following section. While the presentation by
\citet{Retzlaff:18a} is purely theoretical and did not supply a reference
implementation, the present contribution closes this gap.

\section{\uppercase{Theory}}

The basic idea behind the framework of \citet{Retzlaff:18a} boils down to
two ingredients: (1) Each input sequence is either local or global on the
left and either local or global on the right. This is entirely the user's
choice and provided with the input. (2) In a particular alignment column, a
sequence may be \textit{inactive} (if up to this column its prefix is
considered unaligned), \textit{active} (if it contributs to the column
either with one of its characters or with a gap this is scored), or it is
\textit{dead} (if its suffix is considered unaligned). Consequently a
left-local sequence starts out \textit{inactive}, while a left-global
sequence starts out \textit{active}. Correspondingly, a right-global input
is still \textit{active} at the end of the aligment, while a right-local
sequence must be \textit{dead} at the end of the alignment. The partially
local alignment problems can be solved by dynamic programming just as the
classic pairwise problems mentioned in the introduction. As usual, a
scoring (\emph{memoization}) table $S$ holds the optimal alignments of
prefixes. The only difference is that $S$ now depends not only on the
length of prefixes but also on the state (\textit{inactive},
\textit{active}, or \textit{dead}) of each sequence in a given column of
the alignment. It is sufficient to record the set $A$ of \textit{active}
and $D$ of \textit{dead} sequences, since the \emph{inactive} sequences are
given by $X\setminus\{A \cup D\}$.  As the alignment progresses, an
\textit{inactive} sequence may become \textit{active} only once, and an
\textit{active} may transit at most once to the \textit{dead}
state. Consecutive alignment columns thus have state pairs $(A',D')$ and
$(A,D)$ that are comparable w.r.t.\ the partial order
\begin{equation}
  (A',D')\preceq(A,D) \iff
    \begin{cases} A'\cup D'\subseteq A\cup D \\
      D'\subseteq D
    \end{cases}
\end{equation}
The state changes can be performed stepwisely. As shown in
\cite{Retzlaff:18a}, $(A',D')$ is an immediate predecessor of $(A,D)$ if
either exactly on one \textit{inactive} sequence become \textit{active} or
exaclty one \textit{active} sequence transitions to the dead state.  We
denote this relation by $\pprec$. The initial condition is $A=A_0$, where
$A_0$ is the set of left-global sequences, and $D=\emptyset$.

\begin{figure}
  \begin{center}
    \includegraphics[width=0.9\columnwidth]{Fig1.eps}
  \end{center}
  \caption{Schematic representation of the breakpoint alignment model of
    \cite{AlArab:17a}, with global reference sequence $\mathtt{1}$,
    right-local prefix $\mathtt{2}$, and left-local suffix $\mathtt{3}$.
    The initial and terminal states of valid alignments are therefore
    $A|D=\{\mathtt{1},\mathtt{2}\}|\{\}$ and
    $\{\mathtt{1},\mathtt{3}\}|\{\mathtt{2}\}$, respectively.  There are
    two distinct path of transitioning between these states with
    intermediates states $\{\mathtt{1}\}|\{\mathtt{2}\}$ (if $\mathtt{2}$
    and $\mathtt{3}$ do not overlap) and $\{\mathtt{1,2,3}\}|\{\}$ (if
    $\mathtt{2}$ and $\mathtt{3}$ overlap in their aligned part). The black
    bullets indicate that the correspond end of the sequence is present in
    the alignment, open circles indicate the prefixes of suffixes remain
    unaligned.}
  \label{fig:Marwa}
\end{figure}

In a quite general form (which uses the heuristic version of the affine gap
cost model for more than two sequences), the recursion for the optimal
alignment score are of the form
\begin{equation} 
  S^{(A,D)}_I = \max 
      \begin{cases}
        \displaystyle\max_{\pi} 
            \left[ S^{(A,D)}_{I-\pi} + s(\pi)
                    \right]
        \\
        \displaystyle\max_{(A',D')\pprec(A,D)}  
                    \left[ S^{(A,D)}_I + s^*\right]
       \end{cases} 
\label{eq:maxrec}
\end{equation}
The variable$\pi$ (a non-null binary vector) denotes gap pattern in the
last alignment column, the lower multi-index $I$ describes the lengths of
the prefixes included in the alignment including this column.  Thus $I-\pi$
is the vector of prefix lengths in the previous column. The scoring
function $s(\,.\,)$ in the most general form depends on both gap patterns
as well as the actual sequence entries. The second alternative does not
move in the alignment but changes the state, a step that may also be
associated with a cost $s^*$, which in the most general case may depend on
$I,\pi,A,D,A',D'$. Equation~(\ref{eq:maxrec}) describes the recursion for
additive score. The special case that a sequence $k$ that is both left- and
right-local remains completely unaligned is handled by a directed
transition from \textit{inactive} to \textit{dead} restricted to $I_k=0$,
see \citet{Retzlaff:18a} for details.

The notation is illustrated in Fig.~\ref{fig:Marwa} for the algorithm
introduced by \citet{AlArab:17a}. In principle, the recursions are easily
extended to affine gap costs. However, this incurs another factor $(2^N-1)$
in memory for $N$ sequences since the scoring tables $S$ becomes explicitly
dependent on the gap pattern of the last column. The full recursions for
the breakpoint alignment model with affine gap costs, are given in the
appendix of \citet{Retzlaff:18a}.

The backtracing recursion is a rather straightforwards generalization of
the backtracing scheme for the Smith-Waterman algorithm. The first step is
to find the optimal score partially local alignment. Denote by $(A^*,D^*)$
that unique maximal state w.r.t.\ $preceq$, i.e., $A^*$ is the set of all
right-global sequences and $D^*$ is the set of all right-local
sequences. Hence $A^*\cup D^*$ contains all input sequences.  The optimal
score is the maximum over all multi-indices $I$ with constraint that
$I_k=n_k$, the length of the $k$-th sequence, for all $k\in A^*$, with the
the maximum taken over all indices $I_k$ with $k\in D^*$.  The maximum
value of $I_k$ determines the right boundary of the right-local sequence.
The recursion then proceeds, as usual, to find the index or state
transition in Equ.(\ref{eq:maxrec}). The backtracing recursion terminates
as soon as all left-global variables $k\in A_0$ have reached the left end
oft the sequences, i.e., $I_k=0$ for all $k\in A_0$.  The left boundary of
a left-local sequences $l\notin A_0$ equals the index $I_l$ at this point.

Equ.(\ref{eq:maxrec}) is the simplest way to explain the recursive
structure of the partially local alignment problem. It has the disdvantage
that it provides more than one way to obtain a particular partial alignment
(characterized by $I,A,D$) since state transition can be performed in
arbitrary order. As a consequence, equ.(\ref{eq:maxrec}) cannot be used to
compute partition functions over alignments, and hence to obtain a
probabilistic version. As described in some detail in \citet{Retzlaff:18a},
unambiguous recursions can be constructed by allowing state transitions
from \textit{inactive} to \textit{active} and from \textit{active} to
\textit{dead} for a sequence $k$ only in conjunction with appending of a
alignment column for which $\pi_k=1$.  At the same time, one needs to
consider also all possible state transitions with $(A',D')\prec(A,D)$. That
is,
\begin{equation}
  S^{(A,D)}_I = 
  \displaystyle\max_{\pi} \displaystyle\max_{(A',D')}^*
  \left[ S^{(A',D')}_{I-\pi} + s(\pi) + s^* \right]
  \label{eq:maxrec2}
\end{equation}
where $\max_{(A',D')}^*$ runs over all $(A',D')\preceq(A,D)$ such that
$k\in A\setminus A'$ or $k\in D\setminus D'$ implies $\pi_k=1$.

\section{\uppercase{Implementation}}

We have implemented a general alignment algorithm for partially local
alignments with additive gap costs, starting from
equ.(\ref{eq:maxrec2}). In the practical implementation we omit the the
formal initial state $(A_0,\emptyset)$ and separately initialize all
left-local sequences $k$ both in the inactive and the active state for
$I_k=0$. Similarly, we catch die final states at the right end of
right-local sequences without explicitly considering a final transition to
the \textit{dead} state after the last letter has been included into the
alignment. Equ.(\ref{eq:maxrec2}) in general requires the consideration of
more state changes in each step than equ.(\ref{eq:maxrec}). While
equ.(\ref{eq:maxrec}) only considers the Hasse diagraph of the partial
order $\prec$, its transitive closure is required for
equ.(\ref{eq:maxrec2}). On the other hand, equ.(\ref{eq:maxrec2}) provides
a very convenient starting point for later extensions e.g.\ to a
probabilistic version. 

\SAFTWARE{} is written in \texttt{Java} and uses only standard libraries.
In principle, \SAFTWARE{} is capable of accepting an arbitrary number of
input sequences. However, the resource requirements quickly become
prohibitive with the number of input sequences and in particular the number
of local ends. \SAFTWARE{} first explicitly constructs the partial order
$\prec$ and uses this information to allocated the memoization tables for
the recursions. The partial order can be exported in \texttt{.dot} format
and visualized using a standard graph drawing tools such as
\texttt{graphviz}.

The partial order determines the required resources: one
$\prod_{k\in A} O(n_k)$-size table is required for each state $(A,D)$.
Writing $g$=$|A_0\cap A^*|$ for the number of global sequences,
$s=|A_0\setminus A^*|$ + $A^*\setminus A_0$ for the number sequences that
are local and one end and global at the other, and $\ell$ for the number of
local sequences, there are
\begin{equation}
  h = 1^a 2^s 3^{\ell} 
\end{equation} 
distinct states, because global sequences are always \textit{active},
semi-local sequences change either state from \textit{inactive} to to
\textit{active} or from \textit{active} to \textit{dead}, while local
sequences can pass through all three states. All combinations of these
states must be considered, since the relative order (between sequences) of
the state transitions is not constrained.  \PFS{With one index variable
  iterating over each of the $N$ sequences of length $O(n)$, the memory
  requirements are $O(n^N)$ for each state.  The evaluation of the
  recursion requires $O(2^N)$ score computations for each transition
  between columns and states, resulting in an upper bound of
  $O(2^N n^N h^2)$ effort, which could in principle be reduced to
  $O(2^N n^N h N)$ by attempting to implement equ.(\ref{eq:maxrec})
  instead of equ.(\ref{eq:maxrec2}).}

\PFS{Backtracing is implemented in the usual manner: starting from the
  position $I^*$ and state $(A^*,D^*)$ of the optimal score, \SAFTWARE{}
  computes the transition that resulted in the optimal score. At present,
  co-optimal solutions are not investigated. The first solution encountered
  is used. The procedure then continues iteratively until the start state
  is reached.}

\TODO{Nancy, please check if anything of the stuff below is still needed,
  otherwise delete.}

\FK{
\begin{itemize}
    \item an algorithm for exact global multiway-alignments is core of this implementation
    \item an algorithm to construct the hasse diagram (derived from localities)
    \item iteration through the hasse graph computing the score matrices for every state in the right order. 
    \begin{itemize}
        \item to compute one state all the previous states have to be computed
        \item (modified) exact global multiway-alignments per state (for
          each entry of the score matrix it checks whether it can use
          values of the score matrices of its previous states).
          \TODO{what exactly do you mean here?} \\
          when it computes an entry of the actual score matrix it does not only take the three previous entries of this matrix into account, but also values of its previous matrices/states
    \end{itemize}
    \item an algorithm for backtracking
    \begin{itemize}
        \item finds the best starting point in one of the potentially many final states/scoring matrices
        \item tracks back through state transitions 
    \end{itemize}
    \item algorithms to read sequences (fasta), score matrices and localities from input files
\end{itemize}
}

\section{\uppercase{Benchmark}}

We use two well known benchmark protein databases to test and evaluate
\SAFTWARE. \texttt{OXBench} \cite{oxbench} is a completely automatically
generated database whereas \texttt{BAliBASE} \cite{balibase} has a manual
step for cleaning initial alignments before the release. These sequences
are subsequently aligned with \SAFTWARE{} as well as three of the most
common alignment tools: \texttt{T-Coffee} \cite{Notredame:00},
\texttt{MAFFT} \cite{Katoh:05}, and \texttt{ClustalW}
\cite{Larkin:07}. \PFS{All three tools are based on initial pairwise
  alignments and use essentially progressive schemes, hence presenting
  efficient heuristics rather than exact solutions.}

Comparing Figs.~\ref{fig:littleLoc} and \ref{fig:manyLoc} we can see that
the running time of \SAFTWARE, as expected, strongly depends on how many
local ends needs to be handled in one alignment. Since \SAFTWARE{} is
designed as a reference implementation of a much more expensive, exact
algorithm, it is clear that is cannot be competitive in terms resource
consumption. Much more interesting is the question whether the exact
implementation of multi-way can achieve a further improvement in accuracy.

%
% while it yet has to be
% optimized to run faster.
%

\PFS{The average accuracy, defined as $\mbox{AC}=(L-f)/L$ where $L$ is the
  length of the alignment and $f$ is the number of columns deviating from
  the reference alignment, is summarized in Fig.~\ref{fig:ac}. The data
  show that \SAFTWARE{} provides a moderate but noticeable improvement
  relative to all three heuristics, although we use a simple scoring model
  and none of the protein-specific rules implemented e.g.\ in
  \texttt{ClustalW}. 

\begin{figure}
  \begin{center}
    \includegraphics[width=1\columnwidth]{times_smaller4_boxplot.eps}
  \end{center}
  \caption{Running time of \SAFTWARE{} for alignments with at most three
    local ends compared to heuristic global aligners (\texttt{T-Coffee},
    \texttt{MAFFT}, and \texttt{ClustalW}) that are commonly used in
    large-scale bioinformatics applications.}
 \label{fig:littleLoc}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=1\columnwidth]{times_bigger3_boxplot.eps}
  \end{center}
  \caption{Running time of \SAFTWARE{} for alignments with more than three
    local ends compared to heuristic global aligners.}
  \label{fig:manyLoc}
\end{figure}

As predicted by the theoretical considerations above, the time complexity
of \SAFTWARE{} depends very strongly on the number of local ends of
sequences.  Without local ends, i.e., for global alignments, the execution
time of \SAFTWARE{} is comparable with \texttt{T-Coffee}. For partially
local alignment we observe the expected exponential increase with the
nummer of local ends. 

\begin{figure}
  \begin{center}
    \includegraphics[width=1\columnwidth]{ac.eps}
  \end{center}
  \label{fig:ac}
  \caption{Accuracy of \SAFTWARE{} compared to the heuristic global
    alignment tools \texttt{T-Coffee}, \texttt{MAFFT}, and
    \texttt{ClustalW}.}
\end{figure}

\TODO{Ende der Ausbaustrecke}



Since \SAFTWARE{} is an exact alignment tool accuracy is good. ... 

\begin{figure}
  \begin{center}
    \includegraphics[width=1\columnwidth]{pse_compued_correctly.eps}
  \end{center}
  \label{fig:pse}
  \caption{Position shift error of \SAFTWARE{} compared to t\_coffee, mafft and clustalw}
\end{figure}

((Position shift error in alignments created with \SAFTWARE{} is significantly worse than in the other alignments based on t\_coffee, mafft and clustalW. Big position shift errors may arise from alignments with sequences with local ends, which are handled locally in \SAFTWARE{} and globally in the other alignment tools. The comparison on an alignment where some aequences are aligned only partially to a reference alignment where all the aequences are aligned completely then results in a bad PSE.)) Position shift error of alignments aligned with \SAFTWARE{} is much better than the PSE of alignments from the other alignment tools. Thats partly because \SAFTWARE{} uses an exact alignment algorithm. On the other hand, leading characters of left local sequences and ending characters of right local sequences can be left out in order to get the best alignment score. That means, that \SAFTWARE{} is not aligning only moderately suitable prefixes and suffixes of local sequences, that could shift the position of well alinable middle parts of sequences, what then would results in a bad PSE. Omitted sequence parts, however, do not effect the PSE.

If these sequences are then aligned only partially in \SAFTWARE{} alignments and aligned globally in the other tools
}

\TODO{Falco: please also check explicitly that your code works correctly
  for pairwise local alignments against an implementation Smith-Waterman.
  I just want to be sure that we handle the boundary cases with only a
  single active sequence, i.e., nothing to do, correctly.} 

\TODO{maybe include a figure with an example output!} 

\section{\uppercase{Discussion}}

\PFS{%
\SAFTWARE{} is primarily meant as a reference implemention against which
specialized partially local alignments can be tested and benchmarked. We
anticipate at least two use cases. First, \SAFTWARE{} is useful to to
create test cases and help debugging during the development phase of a
specialized exact implementation. More importantly, since \SAFTWARE{}
computed exact solutions for a moderate number of input sequences, it can
be used to generate ground-truth data against which faster heuristics can
be compared. 

The framework of \SAFTWARE{} lends itself to further extensions. First, it
is easily possible to derive a probabilistic version. This essentially
entails a change in the scoring from adding score contributions to
multiplying with the corresponding Boltzmann factors. The corresponding
outside algorithm could easily be constructed along the lines of
\cite{Hoener:15b}. Another extension that could be realized very easily is
to enforce additional constraints on state transitions. For example, it may
be useful in a pattern-based applications to allow the transition to and
from \textit{active} only concurrently, i.e., at the same position relative
to remaining input sequences.

Instead of treating state transitions in an acyclic manner, it is also
possibly to allow multiple transitions from \textit{active} back to
\textit{inactive}. This would allow certain (context dependent) deletions
to occur at a unit cost. Such ``exclusions'' have rarely been considered in
sequence alignment but are of some interest for structured RNAs
\cite{Schirmer:13}. This idea may be of use in particular when sequences
are provided with structural annotation and deletions of entire structural
elements are to be scored in a special way.
}

\FK{
This implementation is not yet optimized in terms of performance. One solution could be an approach of parallelization, namely fine grained multithreading \cite{Martins:01}. But it still has to be shown if this solution is applicable in Java.}

\TODO{maybe also add a sentence or two about potential application to
  language data, where the generality w.r.t the number of input sequences
  becomes important has all the sequence length $n$ are small.}

\TODO{Salbungsvolle schlusssaetze}

\section*{\uppercase{Acknowledgements}}

NR gratefully acknowledges the hospitality of the Santa Fe Institute, where
parts of this work were performed, as well as travel support \TODO{check
  with Manfred if this the correct ack! by ASU-SFI
  Center for Biosocial Complex Systems.}

\vfill
\bibliographystyle{apalike}
{\small
\bibliography{implementGLOCAL}}

\section*{\uppercase{Appendix}}

\TODO{I don't think we will have an appendix.} 


\vfill
\end{document}
